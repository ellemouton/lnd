// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: graph.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addSourceNode = `-- name: AddSourceNode :exec
/* ─────────────────────────────────────────────
   source_nodes table queries
   ─────────────────────────────────────────────
*/

INSERT INTO source_nodes (node_id)
VALUES ($1)
ON CONFLICT (node_id) DO NOTHING
`

func (q *Queries) AddSourceNode(ctx context.Context, nodeID int64) error {
	_, err := q.db.ExecContext(ctx, addSourceNode, nodeID)
	return err
}

const addV1ChannelProof = `-- name: AddV1ChannelProof :execresult
UPDATE channels
SET node_1_signature = $2,
    node_2_signature = $3,
    bitcoin_1_signature = $4,
    bitcoin_2_signature = $5
WHERE scid = $1
  AND version = 1
`

type AddV1ChannelProofParams struct {
	Scid              []byte
	Node1Signature    []byte
	Node2Signature    []byte
	Bitcoin1Signature []byte
	Bitcoin2Signature []byte
}

func (q *Queries) AddV1ChannelProof(ctx context.Context, arg AddV1ChannelProofParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, addV1ChannelProof,
		arg.Scid,
		arg.Node1Signature,
		arg.Node2Signature,
		arg.Bitcoin1Signature,
		arg.Bitcoin2Signature,
	)
}

const countZombieChannels = `-- name: CountZombieChannels :one
SELECT COUNT(*)
FROM zombie_channels
WHERE version = $1
`

func (q *Queries) CountZombieChannels(ctx context.Context, version int16) (int64, error) {
	row := q.db.QueryRowContext(ctx, countZombieChannels, version)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChannel = `-- name: CreateChannel :one
/* ─────────────────────────────────────────────
   channels table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channels (
    version, scid, node_id_1, node_id_2,
    outpoint, capacity, bitcoin_key_1, bitcoin_key_2,
    node_1_signature, node_2_signature, bitcoin_1_signature,
    bitcoin_2_signature
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id
`

type CreateChannelParams struct {
	Version           int16
	Scid              []byte
	NodeID1           int64
	NodeID2           int64
	Outpoint          string
	Capacity          sql.NullInt64
	BitcoinKey1       []byte
	BitcoinKey2       []byte
	Node1Signature    []byte
	Node2Signature    []byte
	Bitcoin1Signature []byte
	Bitcoin2Signature []byte
}

func (q *Queries) CreateChannel(ctx context.Context, arg CreateChannelParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createChannel,
		arg.Version,
		arg.Scid,
		arg.NodeID1,
		arg.NodeID2,
		arg.Outpoint,
		arg.Capacity,
		arg.BitcoinKey1,
		arg.BitcoinKey2,
		arg.Node1Signature,
		arg.Node2Signature,
		arg.Bitcoin1Signature,
		arg.Bitcoin2Signature,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createChannelExtraType = `-- name: CreateChannelExtraType :exec
/* ─────────────────────────────────────────────
   channel_extra_types table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_extra_types (
    channel_id, type, value
)
VALUES ($1, $2, $3)
`

type CreateChannelExtraTypeParams struct {
	ChannelID int64
	Type      int64
	Value     []byte
}

func (q *Queries) CreateChannelExtraType(ctx context.Context, arg CreateChannelExtraTypeParams) error {
	_, err := q.db.ExecContext(ctx, createChannelExtraType, arg.ChannelID, arg.Type, arg.Value)
	return err
}

const deleteChannel = `-- name: DeleteChannel :exec
DELETE FROM channels WHERE id = $1
`

func (q *Queries) DeleteChannel(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteChannel, id)
	return err
}

const deleteChannelPolicyExtraTypes = `-- name: DeleteChannelPolicyExtraTypes :exec
DELETE FROM channel_policy_extra_types
WHERE channel_policy_id = $1
`

func (q *Queries) DeleteChannelPolicyExtraTypes(ctx context.Context, channelPolicyID int64) error {
	_, err := q.db.ExecContext(ctx, deleteChannelPolicyExtraTypes, channelPolicyID)
	return err
}

const deleteExtraNodeType = `-- name: DeleteExtraNodeType :exec
DELETE FROM node_extra_types
WHERE node_id = $1
  AND type = $2
`

type DeleteExtraNodeTypeParams struct {
	NodeID int64
	Type   int64
}

func (q *Queries) DeleteExtraNodeType(ctx context.Context, arg DeleteExtraNodeTypeParams) error {
	_, err := q.db.ExecContext(ctx, deleteExtraNodeType, arg.NodeID, arg.Type)
	return err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes
WHERE id = $1
`

func (q *Queries) DeleteNode(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteNode, id)
	return err
}

const deleteNodeAddresses = `-- name: DeleteNodeAddresses :exec
DELETE FROM node_addresses
WHERE node_id = $1
`

func (q *Queries) DeleteNodeAddresses(ctx context.Context, nodeID int64) error {
	_, err := q.db.ExecContext(ctx, deleteNodeAddresses, nodeID)
	return err
}

const deleteNodeByPubKey = `-- name: DeleteNodeByPubKey :execresult
DELETE FROM nodes
WHERE pub_key = $1
  AND version = $2
`

type DeleteNodeByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) DeleteNodeByPubKey(ctx context.Context, arg DeleteNodeByPubKeyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteNodeByPubKey, arg.PubKey, arg.Version)
}

const deleteNodeFeature = `-- name: DeleteNodeFeature :exec
DELETE FROM node_features
WHERE node_id = $1
  AND feature_bit = $2
`

type DeleteNodeFeatureParams struct {
	NodeID     int64
	FeatureBit int32
}

func (q *Queries) DeleteNodeFeature(ctx context.Context, arg DeleteNodeFeatureParams) error {
	_, err := q.db.ExecContext(ctx, deleteNodeFeature, arg.NodeID, arg.FeatureBit)
	return err
}

const deletePruneLogEntriesInRange = `-- name: DeletePruneLogEntriesInRange :exec
DELETE FROM prune_log
WHERE block_height >= $1
  AND block_height <= $2
`

type DeletePruneLogEntriesInRangeParams struct {
	StartHeight int64
	EndHeight   int64
}

func (q *Queries) DeletePruneLogEntriesInRange(ctx context.Context, arg DeletePruneLogEntriesInRangeParams) error {
	_, err := q.db.ExecContext(ctx, deletePruneLogEntriesInRange, arg.StartHeight, arg.EndHeight)
	return err
}

const deleteUnconnectedNodes = `-- name: DeleteUnconnectedNodes :many
DELETE FROM nodes
WHERE
    -- Ignore any of our source nodes.
    NOT EXISTS (
        SELECT 1
        FROM source_nodes sn
        WHERE sn.node_id = nodes.id
    )
    -- Select all nodes that do not have any channels.
    AND NOT EXISTS (
        SELECT 1
        FROM channels c
        WHERE c.node_id_1 = nodes.id OR c.node_id_2 = nodes.id
) RETURNING pub_key
`

func (q *Queries) DeleteUnconnectedNodes(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.QueryContext(ctx, deleteUnconnectedNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var pub_key []byte
		if err := rows.Scan(&pub_key); err != nil {
			return nil, err
		}
		items = append(items, pub_key)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteZombieChannel = `-- name: DeleteZombieChannel :execresult
DELETE FROM zombie_channels
WHERE scid = $1
AND version = $2
`

type DeleteZombieChannelParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) DeleteZombieChannel(ctx context.Context, arg DeleteZombieChannelParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteZombieChannel, arg.Scid, arg.Version)
}

const getChannelAndNodesBySCID = `-- name: GetChannelAndNodesBySCID :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pub_key,
    n2.pub_key AS node2_pub_key
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
WHERE c.scid = $1
  AND c.version = $2
`

type GetChannelAndNodesBySCIDParams struct {
	Scid    []byte
	Version int16
}

type GetChannelAndNodesBySCIDRow struct {
	ID                int64
	Version           int16
	Scid              []byte
	NodeID1           int64
	NodeID2           int64
	Outpoint          string
	Capacity          sql.NullInt64
	BitcoinKey1       []byte
	BitcoinKey2       []byte
	Node1Signature    []byte
	Node2Signature    []byte
	Bitcoin1Signature []byte
	Bitcoin2Signature []byte
	Node1PubKey       []byte
	Node2PubKey       []byte
}

func (q *Queries) GetChannelAndNodesBySCID(ctx context.Context, arg GetChannelAndNodesBySCIDParams) (GetChannelAndNodesBySCIDRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelAndNodesBySCID, arg.Scid, arg.Version)
	var i GetChannelAndNodesBySCIDRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Scid,
		&i.NodeID1,
		&i.NodeID2,
		&i.Outpoint,
		&i.Capacity,
		&i.BitcoinKey1,
		&i.BitcoinKey2,
		&i.Node1Signature,
		&i.Node2Signature,
		&i.Bitcoin1Signature,
		&i.Bitcoin2Signature,
		&i.Node1PubKey,
		&i.Node2PubKey,
	)
	return i, err
}

const getChannelByOutpoint = `-- name: GetChannelByOutpoint :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
WHERE c.outpoint = $1
`

type GetChannelByOutpointRow struct {
	Channel     Channel
	Node1Pubkey []byte
	Node2Pubkey []byte
}

func (q *Queries) GetChannelByOutpoint(ctx context.Context, outpoint string) (GetChannelByOutpointRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelByOutpoint, outpoint)
	var i GetChannelByOutpointRow
	err := row.Scan(
		&i.Channel.ID,
		&i.Channel.Version,
		&i.Channel.Scid,
		&i.Channel.NodeID1,
		&i.Channel.NodeID2,
		&i.Channel.Outpoint,
		&i.Channel.Capacity,
		&i.Channel.BitcoinKey1,
		&i.Channel.BitcoinKey2,
		&i.Channel.Node1Signature,
		&i.Channel.Node2Signature,
		&i.Channel.Bitcoin1Signature,
		&i.Channel.Bitcoin2Signature,
		&i.Node1Pubkey,
		&i.Node2Pubkey,
	)
	return i, err
}

const getChannelByOutpointWithPolicies = `-- name: GetChannelByOutpointWithPolicies :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,

    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey,

    -- Node 1 policy
    cp1.id AS policy_1_id,
    cp1.node_id AS policy_1_node_id,
    cp1.version AS policy_1_version,
    cp1.timelock AS policy_1_timelock,
    cp1.fee_ppm AS policy_1_fee_ppm,
    cp1.base_fee_msat AS policy_1_base_fee_msat,
    cp1.min_htlc_msat AS policy_1_min_htlc_msat,
    cp1.max_htlc_msat AS policy_1_max_htlc_msat,
    cp1.last_update AS policy_1_last_update,
    cp1.disabled AS policy_1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.message_flags AS policy_1_message_flags,
    cp1.channel_flags AS policy_1_channel_flags,
    cp1.signature AS policy_1_signature,

    -- Node 2 policy
    cp2.id AS policy_2_id,
    cp2.node_id AS policy_2_node_id,
    cp2.version AS policy_2_version,
    cp2.timelock AS policy_2_timelock,
    cp2.fee_ppm AS policy_2_fee_ppm,
    cp2.base_fee_msat AS policy_2_base_fee_msat,
    cp2.min_htlc_msat AS policy_2_min_htlc_msat,
    cp2.max_htlc_msat AS policy_2_max_htlc_msat,
    cp2.last_update AS policy_2_last_update,
    cp2.disabled AS policy_2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.message_flags AS policy_2_message_flags,
    cp2.channel_flags AS policy_2_channel_flags,
    cp2.signature AS policy_2_signature
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
        ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
        ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.outpoint = $1 AND c.version = $2
`

type GetChannelByOutpointWithPoliciesParams struct {
	Outpoint string
	Version  int16
}

type GetChannelByOutpointWithPoliciesRow struct {
	Channel                        Channel
	Node1Pubkey                    []byte
	Node2Pubkey                    []byte
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1MessageFlags            sql.NullInt16
	Policy1ChannelFlags            sql.NullInt16
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2MessageFlags            sql.NullInt16
	Policy2ChannelFlags            sql.NullInt16
	Policy2Signature               []byte
}

func (q *Queries) GetChannelByOutpointWithPolicies(ctx context.Context, arg GetChannelByOutpointWithPoliciesParams) (GetChannelByOutpointWithPoliciesRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelByOutpointWithPolicies, arg.Outpoint, arg.Version)
	var i GetChannelByOutpointWithPoliciesRow
	err := row.Scan(
		&i.Channel.ID,
		&i.Channel.Version,
		&i.Channel.Scid,
		&i.Channel.NodeID1,
		&i.Channel.NodeID2,
		&i.Channel.Outpoint,
		&i.Channel.Capacity,
		&i.Channel.BitcoinKey1,
		&i.Channel.BitcoinKey2,
		&i.Channel.Node1Signature,
		&i.Channel.Node2Signature,
		&i.Channel.Bitcoin1Signature,
		&i.Channel.Bitcoin2Signature,
		&i.Node1Pubkey,
		&i.Node2Pubkey,
		&i.Policy1ID,
		&i.Policy1NodeID,
		&i.Policy1Version,
		&i.Policy1Timelock,
		&i.Policy1FeePpm,
		&i.Policy1BaseFeeMsat,
		&i.Policy1MinHtlcMsat,
		&i.Policy1MaxHtlcMsat,
		&i.Policy1LastUpdate,
		&i.Policy1Disabled,
		&i.Policy1InboundBaseFeeMsat,
		&i.Policy1InboundFeeRateMilliMsat,
		&i.Policy1MessageFlags,
		&i.Policy1ChannelFlags,
		&i.Policy1Signature,
		&i.Policy2ID,
		&i.Policy2NodeID,
		&i.Policy2Version,
		&i.Policy2Timelock,
		&i.Policy2FeePpm,
		&i.Policy2BaseFeeMsat,
		&i.Policy2MinHtlcMsat,
		&i.Policy2MaxHtlcMsat,
		&i.Policy2LastUpdate,
		&i.Policy2Disabled,
		&i.Policy2InboundBaseFeeMsat,
		&i.Policy2InboundFeeRateMilliMsat,
		&i.Policy2MessageFlags,
		&i.Policy2ChannelFlags,
		&i.Policy2Signature,
	)
	return i, err
}

const getChannelBySCID = `-- name: GetChannelBySCID :one
SELECT id, version, scid, node_id_1, node_id_2, outpoint, capacity, bitcoin_key_1, bitcoin_key_2, node_1_signature, node_2_signature, bitcoin_1_signature, bitcoin_2_signature FROM channels
WHERE scid = $1 AND version = $2
`

type GetChannelBySCIDParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) GetChannelBySCID(ctx context.Context, arg GetChannelBySCIDParams) (Channel, error) {
	row := q.db.QueryRowContext(ctx, getChannelBySCID, arg.Scid, arg.Version)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Scid,
		&i.NodeID1,
		&i.NodeID2,
		&i.Outpoint,
		&i.Capacity,
		&i.BitcoinKey1,
		&i.BitcoinKey2,
		&i.Node1Signature,
		&i.Node2Signature,
		&i.Bitcoin1Signature,
		&i.Bitcoin2Signature,
	)
	return i, err
}

const getChannelBySCIDWithPolicies = `-- name: GetChannelBySCIDWithPolicies :one
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.id, n1.version, n1.pub_key, n1.alias, n1.last_update, n1.color, n1.signature,
    n2.id, n2.version, n2.pub_key, n2.alias, n2.last_update, n2.color, n2.signature,

    -- Policy 1
    cp1.id AS policy1_id,
    cp1.node_id AS policy1_node_id,
    cp1.version AS policy1_version,
    cp1.timelock AS policy1_timelock,
    cp1.fee_ppm AS policy1_fee_ppm,
    cp1.base_fee_msat AS policy1_base_fee_msat,
    cp1.min_htlc_msat AS policy1_min_htlc_msat,
    cp1.max_htlc_msat AS policy1_max_htlc_msat,
    cp1.last_update AS policy1_last_update,
    cp1.disabled AS policy1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.message_flags AS policy1_message_flags,
    cp1.channel_flags AS policy1_channel_flags,
    cp1.signature AS policy1_signature,

    -- Policy 2
    cp2.id AS policy2_id,
    cp2.node_id AS policy2_node_id,
    cp2.version AS policy2_version,
    cp2.timelock AS policy2_timelock,
    cp2.fee_ppm AS policy2_fee_ppm,
    cp2.base_fee_msat AS policy2_base_fee_msat,
    cp2.min_htlc_msat AS policy2_min_htlc_msat,
    cp2.max_htlc_msat AS policy2_max_htlc_msat,
    cp2.last_update AS policy2_last_update,
    cp2.disabled AS policy2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.message_flags AS policy_2_message_flags,
    cp2.channel_flags AS policy_2_channel_flags,
    cp2.signature AS policy2_signature

FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
        ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
        ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.scid = $1
  AND c.version = $2
`

type GetChannelBySCIDWithPoliciesParams struct {
	Scid    []byte
	Version int16
}

type GetChannelBySCIDWithPoliciesRow struct {
	Channel                        Channel
	Node                           Node
	Node_2                         Node
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1MessageFlags            sql.NullInt16
	Policy1ChannelFlags            sql.NullInt16
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2MessageFlags            sql.NullInt16
	Policy2ChannelFlags            sql.NullInt16
	Policy2Signature               []byte
}

func (q *Queries) GetChannelBySCIDWithPolicies(ctx context.Context, arg GetChannelBySCIDWithPoliciesParams) (GetChannelBySCIDWithPoliciesRow, error) {
	row := q.db.QueryRowContext(ctx, getChannelBySCIDWithPolicies, arg.Scid, arg.Version)
	var i GetChannelBySCIDWithPoliciesRow
	err := row.Scan(
		&i.Channel.ID,
		&i.Channel.Version,
		&i.Channel.Scid,
		&i.Channel.NodeID1,
		&i.Channel.NodeID2,
		&i.Channel.Outpoint,
		&i.Channel.Capacity,
		&i.Channel.BitcoinKey1,
		&i.Channel.BitcoinKey2,
		&i.Channel.Node1Signature,
		&i.Channel.Node2Signature,
		&i.Channel.Bitcoin1Signature,
		&i.Channel.Bitcoin2Signature,
		&i.Node.ID,
		&i.Node.Version,
		&i.Node.PubKey,
		&i.Node.Alias,
		&i.Node.LastUpdate,
		&i.Node.Color,
		&i.Node.Signature,
		&i.Node_2.ID,
		&i.Node_2.Version,
		&i.Node_2.PubKey,
		&i.Node_2.Alias,
		&i.Node_2.LastUpdate,
		&i.Node_2.Color,
		&i.Node_2.Signature,
		&i.Policy1ID,
		&i.Policy1NodeID,
		&i.Policy1Version,
		&i.Policy1Timelock,
		&i.Policy1FeePpm,
		&i.Policy1BaseFeeMsat,
		&i.Policy1MinHtlcMsat,
		&i.Policy1MaxHtlcMsat,
		&i.Policy1LastUpdate,
		&i.Policy1Disabled,
		&i.Policy1InboundBaseFeeMsat,
		&i.Policy1InboundFeeRateMilliMsat,
		&i.Policy1MessageFlags,
		&i.Policy1ChannelFlags,
		&i.Policy1Signature,
		&i.Policy2ID,
		&i.Policy2NodeID,
		&i.Policy2Version,
		&i.Policy2Timelock,
		&i.Policy2FeePpm,
		&i.Policy2BaseFeeMsat,
		&i.Policy2MinHtlcMsat,
		&i.Policy2MaxHtlcMsat,
		&i.Policy2LastUpdate,
		&i.Policy2Disabled,
		&i.Policy2InboundBaseFeeMsat,
		&i.Policy2InboundFeeRateMilliMsat,
		&i.Policy2MessageFlags,
		&i.Policy2ChannelFlags,
		&i.Policy2Signature,
	)
	return i, err
}

const getChannelFeaturesAndExtras = `-- name: GetChannelFeaturesAndExtras :many
SELECT
    cf.channel_id,
    true AS is_feature,
    cf.feature_bit AS feature_bit,
    NULL AS extra_key,
    NULL AS value
FROM channel_features cf
WHERE cf.channel_id = $1

UNION ALL

SELECT
    cet.channel_id,
    false AS is_feature,
    0 AS feature_bit,
    cet.type AS extra_key,
    cet.value AS value
FROM channel_extra_types cet
WHERE cet.channel_id = $1
`

type GetChannelFeaturesAndExtrasRow struct {
	ChannelID  int64
	IsFeature  bool
	FeatureBit int32
	ExtraKey   interface{}
	Value      interface{}
}

func (q *Queries) GetChannelFeaturesAndExtras(ctx context.Context, channelID int64) ([]GetChannelFeaturesAndExtrasRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelFeaturesAndExtras, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelFeaturesAndExtrasRow
	for rows.Next() {
		var i GetChannelFeaturesAndExtrasRow
		if err := rows.Scan(
			&i.ChannelID,
			&i.IsFeature,
			&i.FeatureBit,
			&i.ExtraKey,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelPolicyByChannelAndNode = `-- name: GetChannelPolicyByChannelAndNode :one
SELECT id, version, channel_id, node_id, timelock, fee_ppm, base_fee_msat, min_htlc_msat, max_htlc_msat, last_update, disabled, inbound_base_fee_msat, inbound_fee_rate_milli_msat, message_flags, channel_flags, signature
FROM channel_policies
WHERE channel_id = $1
  AND node_id = $2
  AND version = $3
`

type GetChannelPolicyByChannelAndNodeParams struct {
	ChannelID int64
	NodeID    int64
	Version   int16
}

func (q *Queries) GetChannelPolicyByChannelAndNode(ctx context.Context, arg GetChannelPolicyByChannelAndNodeParams) (ChannelPolicy, error) {
	row := q.db.QueryRowContext(ctx, getChannelPolicyByChannelAndNode, arg.ChannelID, arg.NodeID, arg.Version)
	var i ChannelPolicy
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.ChannelID,
		&i.NodeID,
		&i.Timelock,
		&i.FeePpm,
		&i.BaseFeeMsat,
		&i.MinHtlcMsat,
		&i.MaxHtlcMsat,
		&i.LastUpdate,
		&i.Disabled,
		&i.InboundBaseFeeMsat,
		&i.InboundFeeRateMilliMsat,
		&i.MessageFlags,
		&i.ChannelFlags,
		&i.Signature,
	)
	return i, err
}

const getChannelPolicyExtraTypes = `-- name: GetChannelPolicyExtraTypes :many
SELECT
    cp.id AS policy_id,
    cp.channel_id,
    cp.node_id,
    cpet.type,
    cpet.value
FROM channel_policies cp
JOIN channel_policy_extra_types cpet
ON cp.id = cpet.channel_policy_id
WHERE cp.id = $1 OR cp.id = $2
`

type GetChannelPolicyExtraTypesParams struct {
	ID   int64
	ID_2 int64
}

type GetChannelPolicyExtraTypesRow struct {
	PolicyID  int64
	ChannelID int64
	NodeID    int64
	Type      int64
	Value     []byte
}

func (q *Queries) GetChannelPolicyExtraTypes(ctx context.Context, arg GetChannelPolicyExtraTypesParams) ([]GetChannelPolicyExtraTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelPolicyExtraTypes, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelPolicyExtraTypesRow
	for rows.Next() {
		var i GetChannelPolicyExtraTypesRow
		if err := rows.Scan(
			&i.PolicyID,
			&i.ChannelID,
			&i.NodeID,
			&i.Type,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelsByPolicyLastUpdateRange = `-- name: GetChannelsByPolicyLastUpdateRange :many
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.id, n1.version, n1.pub_key, n1.alias, n1.last_update, n1.color, n1.signature,
    n2.id, n2.version, n2.pub_key, n2.alias, n2.last_update, n2.color, n2.signature,

    -- Policy 1 (node_id_1)
    cp1.id AS policy1_id,
    cp1.node_id AS policy1_node_id,
    cp1.version AS policy1_version,
    cp1.timelock AS policy1_timelock,
    cp1.fee_ppm AS policy1_fee_ppm,
    cp1.base_fee_msat AS policy1_base_fee_msat,
    cp1.min_htlc_msat AS policy1_min_htlc_msat,
    cp1.max_htlc_msat AS policy1_max_htlc_msat,
    cp1.last_update AS policy1_last_update,
    cp1.disabled AS policy1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.message_flags AS policy1_message_flags,
    cp1.channel_flags AS policy1_channel_flags,
    cp1.signature AS policy1_signature,

    -- Policy 2 (node_id_2)
    cp2.id AS policy2_id,
    cp2.node_id AS policy2_node_id,
    cp2.version AS policy2_version,
    cp2.timelock AS policy2_timelock,
    cp2.fee_ppm AS policy2_fee_ppm,
    cp2.base_fee_msat AS policy2_base_fee_msat,
    cp2.min_htlc_msat AS policy2_min_htlc_msat,
    cp2.max_htlc_msat AS policy2_max_htlc_msat,
    cp2.last_update AS policy2_last_update,
    cp2.disabled AS policy2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.message_flags AS policy2_message_flags,
    cp2.channel_flags AS policy2_channel_flags,
    cp2.signature AS policy2_signature

FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
        ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
        ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.version = $1
  AND (
       (cp1.last_update >= $2 AND cp1.last_update < $3)
       OR
       (cp2.last_update >= $2 AND cp2.last_update < $3)
  )
ORDER BY
    CASE
        WHEN COALESCE(cp1.last_update, 0) >= COALESCE(cp2.last_update, 0)
            THEN COALESCE(cp1.last_update, 0)
        ELSE COALESCE(cp2.last_update, 0)
        END ASC
`

type GetChannelsByPolicyLastUpdateRangeParams struct {
	Version   int16
	StartTime sql.NullInt64
	EndTime   sql.NullInt64
}

type GetChannelsByPolicyLastUpdateRangeRow struct {
	Channel                        Channel
	Node                           Node
	Node_2                         Node
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1MessageFlags            sql.NullInt16
	Policy1ChannelFlags            sql.NullInt16
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2MessageFlags            sql.NullInt16
	Policy2ChannelFlags            sql.NullInt16
	Policy2Signature               []byte
}

func (q *Queries) GetChannelsByPolicyLastUpdateRange(ctx context.Context, arg GetChannelsByPolicyLastUpdateRangeParams) ([]GetChannelsByPolicyLastUpdateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelsByPolicyLastUpdateRange, arg.Version, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelsByPolicyLastUpdateRangeRow
	for rows.Next() {
		var i GetChannelsByPolicyLastUpdateRangeRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node.ID,
			&i.Node.Version,
			&i.Node.PubKey,
			&i.Node.Alias,
			&i.Node.LastUpdate,
			&i.Node.Color,
			&i.Node.Signature,
			&i.Node_2.ID,
			&i.Node_2.Version,
			&i.Node_2.PubKey,
			&i.Node_2.Alias,
			&i.Node_2.LastUpdate,
			&i.Node_2.Color,
			&i.Node_2.Signature,
			&i.Policy1ID,
			&i.Policy1NodeID,
			&i.Policy1Version,
			&i.Policy1Timelock,
			&i.Policy1FeePpm,
			&i.Policy1BaseFeeMsat,
			&i.Policy1MinHtlcMsat,
			&i.Policy1MaxHtlcMsat,
			&i.Policy1LastUpdate,
			&i.Policy1Disabled,
			&i.Policy1InboundBaseFeeMsat,
			&i.Policy1InboundFeeRateMilliMsat,
			&i.Policy1MessageFlags,
			&i.Policy1ChannelFlags,
			&i.Policy1Signature,
			&i.Policy2ID,
			&i.Policy2NodeID,
			&i.Policy2Version,
			&i.Policy2Timelock,
			&i.Policy2FeePpm,
			&i.Policy2BaseFeeMsat,
			&i.Policy2MinHtlcMsat,
			&i.Policy2MaxHtlcMsat,
			&i.Policy2LastUpdate,
			&i.Policy2Disabled,
			&i.Policy2InboundBaseFeeMsat,
			&i.Policy2InboundFeeRateMilliMsat,
			&i.Policy2MessageFlags,
			&i.Policy2ChannelFlags,
			&i.Policy2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChannelsBySCIDRange = `-- name: GetChannelsBySCIDRange :many
SELECT c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pub_key,
    n2.pub_key AS node2_pub_key
FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
WHERE scid >= $1
  AND scid < $2
`

type GetChannelsBySCIDRangeParams struct {
	StartScid []byte
	EndScid   []byte
}

type GetChannelsBySCIDRangeRow struct {
	Channel     Channel
	Node1PubKey []byte
	Node2PubKey []byte
}

func (q *Queries) GetChannelsBySCIDRange(ctx context.Context, arg GetChannelsBySCIDRangeParams) ([]GetChannelsBySCIDRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelsBySCIDRange, arg.StartScid, arg.EndScid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChannelsBySCIDRangeRow
	for rows.Next() {
		var i GetChannelsBySCIDRangeRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node1PubKey,
			&i.Node2PubKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtraNodeTypes = `-- name: GetExtraNodeTypes :many
SELECT node_id, type, value
FROM node_extra_types
WHERE node_id = $1
`

func (q *Queries) GetExtraNodeTypes(ctx context.Context, nodeID int64) ([]NodeExtraType, error) {
	rows, err := q.db.QueryContext(ctx, getExtraNodeTypes, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeExtraType
	for rows.Next() {
		var i NodeExtraType
		if err := rows.Scan(&i.NodeID, &i.Type, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeAddressesByPubKey = `-- name: GetNodeAddressesByPubKey :many
SELECT a.type, a.address
FROM nodes n
LEFT JOIN node_addresses a ON a.node_id = n.id
WHERE n.pub_key = $1 AND n.version = $2
ORDER BY a.type ASC, a.position ASC
`

type GetNodeAddressesByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

type GetNodeAddressesByPubKeyRow struct {
	Type    sql.NullInt16
	Address sql.NullString
}

func (q *Queries) GetNodeAddressesByPubKey(ctx context.Context, arg GetNodeAddressesByPubKeyParams) ([]GetNodeAddressesByPubKeyRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeAddressesByPubKey, arg.PubKey, arg.Version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodeAddressesByPubKeyRow
	for rows.Next() {
		var i GetNodeAddressesByPubKeyRow
		if err := rows.Scan(&i.Type, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeByPubKey = `-- name: GetNodeByPubKey :one
SELECT id, version, pub_key, alias, last_update, color, signature
FROM nodes
WHERE pub_key = $1
  AND version = $2
`

type GetNodeByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) GetNodeByPubKey(ctx context.Context, arg GetNodeByPubKeyParams) (Node, error) {
	row := q.db.QueryRowContext(ctx, getNodeByPubKey, arg.PubKey, arg.Version)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.PubKey,
		&i.Alias,
		&i.LastUpdate,
		&i.Color,
		&i.Signature,
	)
	return i, err
}

const getNodeFeatures = `-- name: GetNodeFeatures :many
SELECT node_id, feature_bit
FROM node_features
WHERE node_id = $1
`

func (q *Queries) GetNodeFeatures(ctx context.Context, nodeID int64) ([]NodeFeature, error) {
	rows, err := q.db.QueryContext(ctx, getNodeFeatures, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NodeFeature
	for rows.Next() {
		var i NodeFeature
		if err := rows.Scan(&i.NodeID, &i.FeatureBit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeFeaturesByPubKey = `-- name: GetNodeFeaturesByPubKey :many
SELECT f.feature_bit
FROM nodes n
    JOIN node_features f ON f.node_id = n.id
WHERE n.pub_key = $1
  AND n.version = $2
`

type GetNodeFeaturesByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) GetNodeFeaturesByPubKey(ctx context.Context, arg GetNodeFeaturesByPubKeyParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getNodeFeaturesByPubKey, arg.PubKey, arg.Version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var feature_bit int32
		if err := rows.Scan(&feature_bit); err != nil {
			return nil, err
		}
		items = append(items, feature_bit)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeIDByPubKey = `-- name: GetNodeIDByPubKey :one
SELECT id
FROM nodes
WHERE pub_key = $1
  AND version = $2
`

type GetNodeIDByPubKeyParams struct {
	PubKey  []byte
	Version int16
}

func (q *Queries) GetNodeIDByPubKey(ctx context.Context, arg GetNodeIDByPubKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNodeIDByPubKey, arg.PubKey, arg.Version)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getNodesByLastUpdateRange = `-- name: GetNodesByLastUpdateRange :many
SELECT id, version, pub_key, alias, last_update, color, signature
FROM nodes
WHERE last_update >= $1
  AND last_update < $2
`

type GetNodesByLastUpdateRangeParams struct {
	StartTime sql.NullInt64
	EndTime   sql.NullInt64
}

func (q *Queries) GetNodesByLastUpdateRange(ctx context.Context, arg GetNodesByLastUpdateRangeParams) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesByLastUpdateRange, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.PubKey,
			&i.Alias,
			&i.LastUpdate,
			&i.Color,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPruneHashByHeight = `-- name: GetPruneHashByHeight :one
SELECT block_hash
FROM prune_log
WHERE block_height = $1
`

func (q *Queries) GetPruneHashByHeight(ctx context.Context, blockHeight int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getPruneHashByHeight, blockHeight)
	var block_hash []byte
	err := row.Scan(&block_hash)
	return block_hash, err
}

const getPruneTip = `-- name: GetPruneTip :one
SELECT block_height, block_hash
FROM prune_log
ORDER BY block_height DESC
LIMIT 1
`

func (q *Queries) GetPruneTip(ctx context.Context) (PruneLog, error) {
	row := q.db.QueryRowContext(ctx, getPruneTip)
	var i PruneLog
	err := row.Scan(&i.BlockHeight, &i.BlockHash)
	return i, err
}

const getPublicV1ChannelsBySCID = `-- name: GetPublicV1ChannelsBySCID :many
SELECT id, version, scid, node_id_1, node_id_2, outpoint, capacity, bitcoin_key_1, bitcoin_key_2, node_1_signature, node_2_signature, bitcoin_1_signature, bitcoin_2_signature
FROM channels
WHERE node_1_signature IS NOT NULL
  AND scid >= $1
  AND scid < $2
`

type GetPublicV1ChannelsBySCIDParams struct {
	StartScid []byte
	EndScid   []byte
}

func (q *Queries) GetPublicV1ChannelsBySCID(ctx context.Context, arg GetPublicV1ChannelsBySCIDParams) ([]Channel, error) {
	rows, err := q.db.QueryContext(ctx, getPublicV1ChannelsBySCID, arg.StartScid, arg.EndScid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Scid,
			&i.NodeID1,
			&i.NodeID2,
			&i.Outpoint,
			&i.Capacity,
			&i.BitcoinKey1,
			&i.BitcoinKey2,
			&i.Node1Signature,
			&i.Node2Signature,
			&i.Bitcoin1Signature,
			&i.Bitcoin2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSCIDByOutpoint = `-- name: GetSCIDByOutpoint :one
SELECT scid from channels
WHERE outpoint = $1 AND version = $2
`

type GetSCIDByOutpointParams struct {
	Outpoint string
	Version  int16
}

func (q *Queries) GetSCIDByOutpoint(ctx context.Context, arg GetSCIDByOutpointParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getSCIDByOutpoint, arg.Outpoint, arg.Version)
	var scid []byte
	err := row.Scan(&scid)
	return scid, err
}

const getSourceNodesByVersion = `-- name: GetSourceNodesByVersion :many
SELECT sn.node_id, n.pub_key
FROM source_nodes sn
    JOIN nodes n ON sn.node_id = n.id
WHERE n.version = $1
`

type GetSourceNodesByVersionRow struct {
	NodeID int64
	PubKey []byte
}

func (q *Queries) GetSourceNodesByVersion(ctx context.Context, version int16) ([]GetSourceNodesByVersionRow, error) {
	rows, err := q.db.QueryContext(ctx, getSourceNodesByVersion, version)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSourceNodesByVersionRow
	for rows.Next() {
		var i GetSourceNodesByVersionRow
		if err := rows.Scan(&i.NodeID, &i.PubKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getV1DisabledSCIDs = `-- name: GetV1DisabledSCIDs :many
SELECT c.scid
FROM channels c
    JOIN channel_policies cp ON cp.channel_id = c.id
WHERE cp.disabled = true
AND c.version = 1
GROUP BY c.scid
HAVING COUNT(*) > 1
`

// NOTE: this is V1 specific since for V1, disabled is a
// simple, single boolean. The proposed V2 policy
// structure will have a more complex disabled bit vector
// and so the query for V2 may differ.
func (q *Queries) GetV1DisabledSCIDs(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.QueryContext(ctx, getV1DisabledSCIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var scid []byte
		if err := rows.Scan(&scid); err != nil {
			return nil, err
		}
		items = append(items, scid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZombieChannel = `-- name: GetZombieChannel :one
SELECT scid, version, node_key_1, node_key_2
FROM zombie_channels
WHERE scid = $1
AND version = $2
`

type GetZombieChannelParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) GetZombieChannel(ctx context.Context, arg GetZombieChannelParams) (ZombieChannel, error) {
	row := q.db.QueryRowContext(ctx, getZombieChannel, arg.Scid, arg.Version)
	var i ZombieChannel
	err := row.Scan(
		&i.Scid,
		&i.Version,
		&i.NodeKey1,
		&i.NodeKey2,
	)
	return i, err
}

const highestSCID = `-- name: HighestSCID :one
SELECT scid
FROM channels
WHERE version = $1
ORDER BY scid DESC
LIMIT 1
`

func (q *Queries) HighestSCID(ctx context.Context, version int16) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, highestSCID, version)
	var scid []byte
	err := row.Scan(&scid)
	return scid, err
}

const insertChanPolicyExtraType = `-- name: InsertChanPolicyExtraType :exec
/* ─────────────────────────────────────────────
   channel_policy_extra_types table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_policy_extra_types (
    channel_policy_id, type, value
)
VALUES ($1, $2, $3)
`

type InsertChanPolicyExtraTypeParams struct {
	ChannelPolicyID int64
	Type            int64
	Value           []byte
}

func (q *Queries) InsertChanPolicyExtraType(ctx context.Context, arg InsertChanPolicyExtraTypeParams) error {
	_, err := q.db.ExecContext(ctx, insertChanPolicyExtraType, arg.ChannelPolicyID, arg.Type, arg.Value)
	return err
}

const insertChannelFeature = `-- name: InsertChannelFeature :exec
/* ─────────────────────────────────────────────
   channel_features table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_features (
    channel_id, feature_bit
) VALUES (
    $1, $2
)
`

type InsertChannelFeatureParams struct {
	ChannelID  int64
	FeatureBit int32
}

func (q *Queries) InsertChannelFeature(ctx context.Context, arg InsertChannelFeatureParams) error {
	_, err := q.db.ExecContext(ctx, insertChannelFeature, arg.ChannelID, arg.FeatureBit)
	return err
}

const insertClosedChannel = `-- name: InsertClosedChannel :exec
/* ─────────────────────────────────────────────
   closed_scid table queries
   ────────────────────────────────────────────-
*/

INSERT INTO closed_scids (scid)
VALUES ($1)
ON CONFLICT (scid) DO NOTHING
`

func (q *Queries) InsertClosedChannel(ctx context.Context, scid []byte) error {
	_, err := q.db.ExecContext(ctx, insertClosedChannel, scid)
	return err
}

const insertNodeAddress = `-- name: InsertNodeAddress :exec
/* ─────────────────────────────────────────────
   node_addresses table queries
   ─────────────────────────────────────────────
*/

INSERT INTO node_addresses (
    node_id,
    type,
    address,
    position
) VALUES (
    $1, $2, $3, $4
 )
`

type InsertNodeAddressParams struct {
	NodeID   int64
	Type     int16
	Address  string
	Position int32
}

func (q *Queries) InsertNodeAddress(ctx context.Context, arg InsertNodeAddressParams) error {
	_, err := q.db.ExecContext(ctx, insertNodeAddress,
		arg.NodeID,
		arg.Type,
		arg.Address,
		arg.Position,
	)
	return err
}

const insertNodeFeature = `-- name: InsertNodeFeature :exec
/* ─────────────────────────────────────────────
   node_features table queries
   ─────────────────────────────────────────────
*/

INSERT INTO node_features (
    node_id, feature_bit
) VALUES (
    $1, $2
)
`

type InsertNodeFeatureParams struct {
	NodeID     int64
	FeatureBit int32
}

func (q *Queries) InsertNodeFeature(ctx context.Context, arg InsertNodeFeatureParams) error {
	_, err := q.db.ExecContext(ctx, insertNodeFeature, arg.NodeID, arg.FeatureBit)
	return err
}

const isClosedChannel = `-- name: IsClosedChannel :one
SELECT EXISTS (
    SELECT 1
    FROM closed_scids
    WHERE scid = $1
)
`

func (q *Queries) IsClosedChannel(ctx context.Context, scid []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, isClosedChannel, scid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isPublicV1Node = `-- name: IsPublicV1Node :one
SELECT EXISTS (
    SELECT 1
    FROM channels c
    JOIN nodes n ON n.id = c.node_id_1 OR n.id = c.node_id_2
    -- NOTE: we hard-code the version here since the clauses
    -- here that determine if a node is public is specific
    -- to the V1 gossip protocol. In V1, a node is public
    -- if it has a public channel and a public channel is one
    -- where we have the set of signatures of the channel
    -- announcement. It is enough to just check that we have
    -- one of the signatures since we only ever set them
    -- together.
    WHERE c.version = 1
      AND c.bitcoin_1_signature IS NOT NULL
      AND n.pub_key = $1
)
`

func (q *Queries) IsPublicV1Node(ctx context.Context, pubKey []byte) (bool, error) {
	row := q.db.QueryRowContext(ctx, isPublicV1Node, pubKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isZombieChannel = `-- name: IsZombieChannel :one
SELECT EXISTS (
    SELECT 1
    FROM zombie_channels
    WHERE scid = $1
    AND version = $2
) AS is_zombie
`

type IsZombieChannelParams struct {
	Scid    []byte
	Version int16
}

func (q *Queries) IsZombieChannel(ctx context.Context, arg IsZombieChannelParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isZombieChannel, arg.Scid, arg.Version)
	var is_zombie bool
	err := row.Scan(&is_zombie)
	return is_zombie, err
}

const listChannelsByNodeID = `-- name: ListChannelsByNodeID :many
SELECT c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,
    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey,

    -- Policy 1
    -- TODO(elle): use sqlc.embed to embed policy structs
    --  once this issue is resolved:
    --  https://github.com/sqlc-dev/sqlc/issues/2997
    cp1.id AS policy1_id,
    cp1.node_id AS policy1_node_id,
    cp1.version AS policy1_version,
    cp1.timelock AS policy1_timelock,
    cp1.fee_ppm AS policy1_fee_ppm,
    cp1.base_fee_msat AS policy1_base_fee_msat,
    cp1.min_htlc_msat AS policy1_min_htlc_msat,
    cp1.max_htlc_msat AS policy1_max_htlc_msat,
    cp1.last_update AS policy1_last_update,
    cp1.disabled AS policy1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.message_flags AS policy1_message_flags,
    cp1.channel_flags AS policy1_channel_flags,
    cp1.signature AS policy1_signature,

       -- Policy 2
    cp2.id AS policy2_id,
    cp2.node_id AS policy2_node_id,
    cp2.version AS policy2_version,
    cp2.timelock AS policy2_timelock,
    cp2.fee_ppm AS policy2_fee_ppm,
    cp2.base_fee_msat AS policy2_base_fee_msat,
    cp2.min_htlc_msat AS policy2_min_htlc_msat,
    cp2.max_htlc_msat AS policy2_max_htlc_msat,
    cp2.last_update AS policy2_last_update,
    cp2.disabled AS policy2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.message_flags AS policy2_message_flags,
    cp2.channel_flags AS policy2_channel_flags,
    cp2.signature AS policy2_signature

FROM channels c
    JOIN nodes n1 ON c.node_id_1 = n1.id
    JOIN nodes n2 ON c.node_id_2 = n2.id
    LEFT JOIN channel_policies cp1
    ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
    LEFT JOIN channel_policies cp2
    ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.version = $1
  AND (c.node_id_1 = $2 OR c.node_id_2 = $2)
`

type ListChannelsByNodeIDParams struct {
	Version int16
	NodeID1 int64
}

type ListChannelsByNodeIDRow struct {
	Channel                        Channel
	Node1Pubkey                    []byte
	Node2Pubkey                    []byte
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1MessageFlags            sql.NullInt16
	Policy1ChannelFlags            sql.NullInt16
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2MessageFlags            sql.NullInt16
	Policy2ChannelFlags            sql.NullInt16
	Policy2Signature               []byte
}

func (q *Queries) ListChannelsByNodeID(ctx context.Context, arg ListChannelsByNodeIDParams) ([]ListChannelsByNodeIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsByNodeID, arg.Version, arg.NodeID1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsByNodeIDRow
	for rows.Next() {
		var i ListChannelsByNodeIDRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node1Pubkey,
			&i.Node2Pubkey,
			&i.Policy1ID,
			&i.Policy1NodeID,
			&i.Policy1Version,
			&i.Policy1Timelock,
			&i.Policy1FeePpm,
			&i.Policy1BaseFeeMsat,
			&i.Policy1MinHtlcMsat,
			&i.Policy1MaxHtlcMsat,
			&i.Policy1LastUpdate,
			&i.Policy1Disabled,
			&i.Policy1InboundBaseFeeMsat,
			&i.Policy1InboundFeeRateMilliMsat,
			&i.Policy1MessageFlags,
			&i.Policy1ChannelFlags,
			&i.Policy1Signature,
			&i.Policy2ID,
			&i.Policy2NodeID,
			&i.Policy2Version,
			&i.Policy2Timelock,
			&i.Policy2FeePpm,
			&i.Policy2BaseFeeMsat,
			&i.Policy2MinHtlcMsat,
			&i.Policy2MaxHtlcMsat,
			&i.Policy2LastUpdate,
			&i.Policy2Disabled,
			&i.Policy2InboundBaseFeeMsat,
			&i.Policy2InboundFeeRateMilliMsat,
			&i.Policy2MessageFlags,
			&i.Policy2ChannelFlags,
			&i.Policy2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannelsPaginated = `-- name: ListChannelsPaginated :many
SELECT id, bitcoin_key_1, bitcoin_key_2, outpoint
FROM channels c
WHERE c.version = $1 AND c.id > $2
ORDER BY c.id
LIMIT $3
`

type ListChannelsPaginatedParams struct {
	Version int16
	ID      int64
	Limit   int32
}

type ListChannelsPaginatedRow struct {
	ID          int64
	BitcoinKey1 []byte
	BitcoinKey2 []byte
	Outpoint    string
}

func (q *Queries) ListChannelsPaginated(ctx context.Context, arg ListChannelsPaginatedParams) ([]ListChannelsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsPaginated, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsPaginatedRow
	for rows.Next() {
		var i ListChannelsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.BitcoinKey1,
			&i.BitcoinKey2,
			&i.Outpoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChannelsWithPoliciesPaginated = `-- name: ListChannelsWithPoliciesPaginated :many
SELECT
    c.id, c.version, c.scid, c.node_id_1, c.node_id_2, c.outpoint, c.capacity, c.bitcoin_key_1, c.bitcoin_key_2, c.node_1_signature, c.node_2_signature, c.bitcoin_1_signature, c.bitcoin_2_signature,

    -- Join node pubkeys
    n1.pub_key AS node1_pubkey,
    n2.pub_key AS node2_pubkey,

    -- Node 1 policy
    cp1.id AS policy_1_id,
    cp1.node_id AS policy_1_node_id,
    cp1.version AS policy_1_version,
    cp1.timelock AS policy_1_timelock,
    cp1.fee_ppm AS policy_1_fee_ppm,
    cp1.base_fee_msat AS policy_1_base_fee_msat,
    cp1.min_htlc_msat AS policy_1_min_htlc_msat,
    cp1.max_htlc_msat AS policy_1_max_htlc_msat,
    cp1.last_update AS policy_1_last_update,
    cp1.disabled AS policy_1_disabled,
    cp1.inbound_base_fee_msat AS policy1_inbound_base_fee_msat,
    cp1.inbound_fee_rate_milli_msat AS policy1_inbound_fee_rate_milli_msat,
    cp1.message_flags AS policy1_message_flags,
    cp1.channel_flags AS policy1_channel_flags,
    cp1.signature AS policy_1_signature,

    -- Node 2 policy
    cp2.id AS policy_2_id,
    cp2.node_id AS policy_2_node_id,
    cp2.version AS policy_2_version,
    cp2.timelock AS policy_2_timelock,
    cp2.fee_ppm AS policy_2_fee_ppm,
    cp2.base_fee_msat AS policy_2_base_fee_msat,
    cp2.min_htlc_msat AS policy_2_min_htlc_msat,
    cp2.max_htlc_msat AS policy_2_max_htlc_msat,
    cp2.last_update AS policy_2_last_update,
    cp2.disabled AS policy_2_disabled,
    cp2.inbound_base_fee_msat AS policy2_inbound_base_fee_msat,
    cp2.inbound_fee_rate_milli_msat AS policy2_inbound_fee_rate_milli_msat,
    cp2.message_flags AS policy2_message_flags,
    cp2.channel_flags AS policy2_channel_flags,
    cp2.signature AS policy_2_signature

FROM channels c
JOIN nodes n1 ON c.node_id_1 = n1.id
JOIN nodes n2 ON c.node_id_2 = n2.id
LEFT JOIN channel_policies cp1
    ON cp1.channel_id = c.id AND cp1.node_id = c.node_id_1 AND cp1.version = c.version
LEFT JOIN channel_policies cp2
    ON cp2.channel_id = c.id AND cp2.node_id = c.node_id_2 AND cp2.version = c.version
WHERE c.version = $1 AND c.id > $2
ORDER BY c.id
LIMIT $3
`

type ListChannelsWithPoliciesPaginatedParams struct {
	Version int16
	ID      int64
	Limit   int32
}

type ListChannelsWithPoliciesPaginatedRow struct {
	Channel                        Channel
	Node1Pubkey                    []byte
	Node2Pubkey                    []byte
	Policy1ID                      sql.NullInt64
	Policy1NodeID                  sql.NullInt64
	Policy1Version                 sql.NullInt16
	Policy1Timelock                sql.NullInt32
	Policy1FeePpm                  sql.NullInt64
	Policy1BaseFeeMsat             sql.NullInt64
	Policy1MinHtlcMsat             sql.NullInt64
	Policy1MaxHtlcMsat             sql.NullInt64
	Policy1LastUpdate              sql.NullInt64
	Policy1Disabled                sql.NullBool
	Policy1InboundBaseFeeMsat      sql.NullInt64
	Policy1InboundFeeRateMilliMsat sql.NullInt64
	Policy1MessageFlags            sql.NullInt16
	Policy1ChannelFlags            sql.NullInt16
	Policy1Signature               []byte
	Policy2ID                      sql.NullInt64
	Policy2NodeID                  sql.NullInt64
	Policy2Version                 sql.NullInt16
	Policy2Timelock                sql.NullInt32
	Policy2FeePpm                  sql.NullInt64
	Policy2BaseFeeMsat             sql.NullInt64
	Policy2MinHtlcMsat             sql.NullInt64
	Policy2MaxHtlcMsat             sql.NullInt64
	Policy2LastUpdate              sql.NullInt64
	Policy2Disabled                sql.NullBool
	Policy2InboundBaseFeeMsat      sql.NullInt64
	Policy2InboundFeeRateMilliMsat sql.NullInt64
	Policy2MessageFlags            sql.NullInt16
	Policy2ChannelFlags            sql.NullInt16
	Policy2Signature               []byte
}

func (q *Queries) ListChannelsWithPoliciesPaginated(ctx context.Context, arg ListChannelsWithPoliciesPaginatedParams) ([]ListChannelsWithPoliciesPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listChannelsWithPoliciesPaginated, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChannelsWithPoliciesPaginatedRow
	for rows.Next() {
		var i ListChannelsWithPoliciesPaginatedRow
		if err := rows.Scan(
			&i.Channel.ID,
			&i.Channel.Version,
			&i.Channel.Scid,
			&i.Channel.NodeID1,
			&i.Channel.NodeID2,
			&i.Channel.Outpoint,
			&i.Channel.Capacity,
			&i.Channel.BitcoinKey1,
			&i.Channel.BitcoinKey2,
			&i.Channel.Node1Signature,
			&i.Channel.Node2Signature,
			&i.Channel.Bitcoin1Signature,
			&i.Channel.Bitcoin2Signature,
			&i.Node1Pubkey,
			&i.Node2Pubkey,
			&i.Policy1ID,
			&i.Policy1NodeID,
			&i.Policy1Version,
			&i.Policy1Timelock,
			&i.Policy1FeePpm,
			&i.Policy1BaseFeeMsat,
			&i.Policy1MinHtlcMsat,
			&i.Policy1MaxHtlcMsat,
			&i.Policy1LastUpdate,
			&i.Policy1Disabled,
			&i.Policy1InboundBaseFeeMsat,
			&i.Policy1InboundFeeRateMilliMsat,
			&i.Policy1MessageFlags,
			&i.Policy1ChannelFlags,
			&i.Policy1Signature,
			&i.Policy2ID,
			&i.Policy2NodeID,
			&i.Policy2Version,
			&i.Policy2Timelock,
			&i.Policy2FeePpm,
			&i.Policy2BaseFeeMsat,
			&i.Policy2MinHtlcMsat,
			&i.Policy2MaxHtlcMsat,
			&i.Policy2LastUpdate,
			&i.Policy2Disabled,
			&i.Policy2InboundBaseFeeMsat,
			&i.Policy2InboundFeeRateMilliMsat,
			&i.Policy2MessageFlags,
			&i.Policy2ChannelFlags,
			&i.Policy2Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeIDsAndPubKeys = `-- name: ListNodeIDsAndPubKeys :many
SELECT id, pub_key
FROM nodes
WHERE version = $1  AND id > $2
ORDER BY id
LIMIT $3
`

type ListNodeIDsAndPubKeysParams struct {
	Version int16
	ID      int64
	Limit   int32
}

type ListNodeIDsAndPubKeysRow struct {
	ID     int64
	PubKey []byte
}

func (q *Queries) ListNodeIDsAndPubKeys(ctx context.Context, arg ListNodeIDsAndPubKeysParams) ([]ListNodeIDsAndPubKeysRow, error) {
	rows, err := q.db.QueryContext(ctx, listNodeIDsAndPubKeys, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNodeIDsAndPubKeysRow
	for rows.Next() {
		var i ListNodeIDsAndPubKeysRow
		if err := rows.Scan(&i.ID, &i.PubKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesPaginated = `-- name: ListNodesPaginated :many
SELECT id, version, pub_key, alias, last_update, color, signature
FROM nodes
WHERE version = $1 AND id > $2
ORDER BY id
LIMIT $3
`

type ListNodesPaginatedParams struct {
	Version int16
	ID      int64
	Limit   int32
}

func (q *Queries) ListNodesPaginated(ctx context.Context, arg ListNodesPaginatedParams) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, listNodesPaginated, arg.Version, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.PubKey,
			&i.Alias,
			&i.LastUpdate,
			&i.Color,
			&i.Signature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEdgePolicy = `-- name: UpsertEdgePolicy :one
/* ─────────────────────────────────────────────
   channel_policies table queries
   ─────────────────────────────────────────────
*/

INSERT INTO channel_policies (
    version, channel_id, node_id, timelock, fee_ppm,
    base_fee_msat, min_htlc_msat, last_update, disabled,
    max_htlc_msat, inbound_base_fee_msat,
    inbound_fee_rate_milli_msat, message_flags, channel_flags,
    signature
) VALUES  (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
)
ON CONFLICT (channel_id, node_id, version)
    -- Update the following fields if a conflict occurs on channel_id,
    -- node_id, and version.
    DO UPDATE SET
        timelock = EXCLUDED.timelock,
        fee_ppm = EXCLUDED.fee_ppm,
        base_fee_msat = EXCLUDED.base_fee_msat,
        min_htlc_msat = EXCLUDED.min_htlc_msat,
        last_update = EXCLUDED.last_update,
        disabled = EXCLUDED.disabled,
        max_htlc_msat = EXCLUDED.max_htlc_msat,
        inbound_base_fee_msat = EXCLUDED.inbound_base_fee_msat,
        inbound_fee_rate_milli_msat = EXCLUDED.inbound_fee_rate_milli_msat,
        message_flags = EXCLUDED.message_flags,
        channel_flags = EXCLUDED.channel_flags,
        signature = EXCLUDED.signature
WHERE EXCLUDED.last_update > channel_policies.last_update
RETURNING id
`

type UpsertEdgePolicyParams struct {
	Version                 int16
	ChannelID               int64
	NodeID                  int64
	Timelock                int32
	FeePpm                  int64
	BaseFeeMsat             int64
	MinHtlcMsat             int64
	LastUpdate              sql.NullInt64
	Disabled                sql.NullBool
	MaxHtlcMsat             sql.NullInt64
	InboundBaseFeeMsat      sql.NullInt64
	InboundFeeRateMilliMsat sql.NullInt64
	MessageFlags            sql.NullInt16
	ChannelFlags            sql.NullInt16
	Signature               []byte
}

func (q *Queries) UpsertEdgePolicy(ctx context.Context, arg UpsertEdgePolicyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertEdgePolicy,
		arg.Version,
		arg.ChannelID,
		arg.NodeID,
		arg.Timelock,
		arg.FeePpm,
		arg.BaseFeeMsat,
		arg.MinHtlcMsat,
		arg.LastUpdate,
		arg.Disabled,
		arg.MaxHtlcMsat,
		arg.InboundBaseFeeMsat,
		arg.InboundFeeRateMilliMsat,
		arg.MessageFlags,
		arg.ChannelFlags,
		arg.Signature,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertNode = `-- name: UpsertNode :one
/* ─────────────────────────────────────────────
   nodes table queries
   ─────────────────────────────────────────────
*/

INSERT INTO nodes (
    version, pub_key, alias, last_update, color, signature
) VALUES (
    $1, $2, $3, $4, $5, $6
)
ON CONFLICT (pub_key, version)
    -- Update the following fields if a conflict occurs on pub_key
    -- and version.
    DO UPDATE SET
        alias = EXCLUDED.alias,
        last_update = EXCLUDED.last_update,
        color = EXCLUDED.color,
        signature = EXCLUDED.signature
WHERE nodes.last_update IS NULL
    OR EXCLUDED.last_update > nodes.last_update
RETURNING id
`

type UpsertNodeParams struct {
	Version    int16
	PubKey     []byte
	Alias      sql.NullString
	LastUpdate sql.NullInt64
	Color      sql.NullString
	Signature  []byte
}

func (q *Queries) UpsertNode(ctx context.Context, arg UpsertNodeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertNode,
		arg.Version,
		arg.PubKey,
		arg.Alias,
		arg.LastUpdate,
		arg.Color,
		arg.Signature,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertNodeExtraType = `-- name: UpsertNodeExtraType :exec
/* ─────────────────────────────────────────────
   node_extra_types table queries
   ─────────────────────────────────────────────
*/

INSERT INTO node_extra_types (
    node_id, type, value
)
VALUES ($1, $2, $3)
ON CONFLICT (type, node_id)
    -- Update the value if a conflict occurs on type
    -- and node_id.
    DO UPDATE SET value = EXCLUDED.value
`

type UpsertNodeExtraTypeParams struct {
	NodeID int64
	Type   int64
	Value  []byte
}

func (q *Queries) UpsertNodeExtraType(ctx context.Context, arg UpsertNodeExtraTypeParams) error {
	_, err := q.db.ExecContext(ctx, upsertNodeExtraType, arg.NodeID, arg.Type, arg.Value)
	return err
}

const upsertPruneLogEntry = `-- name: UpsertPruneLogEntry :exec
/* ─────────────────────────────────────────────
    prune_log table queries
    ─────────────────────────────────────────────
*/

INSERT INTO prune_log (
    block_height, block_hash
) VALUES (
    $1, $2
)
ON CONFLICT(block_height) DO UPDATE SET
    block_hash = EXCLUDED.block_hash
`

type UpsertPruneLogEntryParams struct {
	BlockHeight int64
	BlockHash   []byte
}

func (q *Queries) UpsertPruneLogEntry(ctx context.Context, arg UpsertPruneLogEntryParams) error {
	_, err := q.db.ExecContext(ctx, upsertPruneLogEntry, arg.BlockHeight, arg.BlockHash)
	return err
}

const upsertZombieChannel = `-- name: UpsertZombieChannel :exec
/* ─────────────────────────────────────────────
   zombie_channels table queries
   ─────────────────────────────────────────────
*/

INSERT INTO zombie_channels (scid, version, node_key_1, node_key_2)
VALUES ($1, $2, $3, $4)
ON CONFLICT (scid, version)
DO UPDATE SET
    -- If a conflict exists for the SCID and version pair, then we
    -- update the node keys.
    node_key_1 = COALESCE(EXCLUDED.node_key_1, zombie_channels.node_key_1),
    node_key_2 = COALESCE(EXCLUDED.node_key_2, zombie_channels.node_key_2)
`

type UpsertZombieChannelParams struct {
	Scid     []byte
	Version  int16
	NodeKey1 []byte
	NodeKey2 []byte
}

func (q *Queries) UpsertZombieChannel(ctx context.Context, arg UpsertZombieChannelParams) error {
	_, err := q.db.ExecContext(ctx, upsertZombieChannel,
		arg.Scid,
		arg.Version,
		arg.NodeKey1,
		arg.NodeKey2,
	)
	return err
}
